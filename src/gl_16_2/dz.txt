Не все тесты пройдены, есть ошибки :(


Количество затраченных попыток: 2

Время выполнения: 0.950148 сек

Общая статистика

Всего тестов: 4. Пройдено: 3. Не пройдено: 1.

Подробную информацию по каждому тесту смотрите ниже.
Тест 1
Тест пройден успешно ✓

Формулировка:

* Итоговый код для проверки.

import warnings

warnings.filterwarnings('ignore')

# Перенесите сюда свой код из прошлой домашки и продолжите работу с ним
from abc import ABC, abstractmethod
 
class InitPrintMixin:
    def __init_print__(self, *args):
        class_name = self.__class__.__name__
        params = ', '.join([f"'{arg}'" if isinstance(arg, str) else str(arg) for arg in args])
        print(f"{class_name}({params})")
 
class BaseProduct(ABC):
    def __init__(self, name, description, price, quantity):
        self.name = name
        self.description = description
        self._price = price
        self.quantity = quantity
 
    @property
    def price(self):
        return self._price
 
    @price.setter
    def price(self, value):
        if value <= 0:
            print("Цена не должна быть нулевая или отрицательная")
        else:
            self._price = value
 
    @abstractmethod
    def __str__(self):
        pass
 
    @classmethod
    @abstractmethod
    def new_product(cls, product_dict):
        pass
 
    def __add__(self, other):
        if type(self) is type(other):
            return self.price * self.quantity + other.price * other.quantity
        raise TypeError("Складывать можно только товары одного типа")
 
    def __len__(self):
        return self.quantity
 
class Product(BaseProduct, InitPrintMixin):
    def __init__(self, name, description, price, quantity):
        super().__init__(name, description, price, quantity)
        self.__init_print__(name, description, price, quantity)
 
    def __str__(self):
        return f"{self.name}, {self.price} руб. Остаток: {self.quantity} шт."
 
    def __repr__(self):
        return f"Product('{self.name}', '{self.description}', {self.price}, {self.quantity})"
 
    @classmethod
    def new_product(cls, product_dict):
        return cls(product_dict['name'], product_dict['description'], product_dict['price'], product_dict['quantity'])
 
class Smartphone(Product):
    def __init__(self, name, description, price, quantity, efficiency='Не указано', model='Не указано', memory=0, color='Не указан'):
        super(Product, self).__init__(name, description, price, quantity)  # Call BaseProduct directly to avoid double print
        self.efficiency = efficiency
        self.model = model
        self.memory = memory
        self.color = color
        self.__init_print__(name, description, price, quantity)
 
    def __repr__(self):
        return f"Smartphone('{self.name}', '{self.description}', {self.price}, {self.quantity})"
 
    @classmethod
    def new_product(cls, product_dict):
        return cls(
            product_dict['name'],
            product_dict['description'],
            product_dict['price'],
            product_dict['quantity'],
            product_dict.get('efficiency', 'Не указано'),
            product_dict.get('model', 'Не указано'),
            product_dict.get('memory', 0),
            product_dict.get('color', 'Не указан')
        )
 
    def __str__(self):
        return f"{self.name} ({self.model}), {self.price} руб. Остаток: {self.quantity} шт., цвет: {self.color}, память: {self.memory} ГБ, производительность: {self.efficiency}"
 
class LawnGrass(Product):
    def __init__(self, name, description, price, quantity, country='Не указано', germination_period='Не указано', color='Не указан'):
        super(Product, self).__init__(name, description, price, quantity)  # Call BaseProduct directly to avoid double print
        self.country = country
        self.germination_period = germination_period
        self.color = color
        self.__init_print__(name, description, price, quantity)
 
    def __repr__(self):
        return f"LawnGrass('{self.name}', '{self.description}', {self.price}, {self.quantity})"
 
    @classmethod
    def new_product(cls, product_dict):
        return cls(
            product_dict['name'],
            product_dict['description'],
            product_dict['price'],
            product_dict['quantity'],
            product_dict.get('country', 'Не указано'),
            product_dict.get('germination_period', 'Не указано'),
            product_dict.get('color', 'Не указан')
        )
 
    def __str__(self):
        return f"{self.name}, {self.price} руб. Остаток: {self.quantity} шт., страна: {self.country}, срок прорастания: {self.germination_period} дней, цвет: {self.color}"
 
class Category:
    category_count = 0
    product_count = 0
 
    def __init__(self, name, description, products=None):
        self.name = name
        self.description = description
        if products is None:
            products = []
        self._products = products
        Category.category_count += 1
        Category.product_count += len(products)
 
    def add_product(self, product):
        if isinstance(product, BaseProduct):
            self._products.append(product)
            Category.product_count += 1
        else:
            raise TypeError("Можно добавить только объекты класса Product или его наследников (Smartphone/LawnGrass)")
 
    @property
    def products(self):
        return "\n".join(str(product) for product in self._products)
 
    def __str__(self):
        total_quantity = sum(len(product) for product in self._products)
        return f"{self.name}, количество продуктов: {total_quantity} шт." 


data = [
    {
        "name": "Смартфоны",
        "description": "Смартфоны, как средство не только коммуникации, но и получение дополнительных функций для удобства жизни",
        "products": [
            {
                "name": "Samsung Galaxy C23 Ultra",
                "description": "256GB, Серый цвет, 200MP камера",
                "price": 180000.0,
                "quantity": 5
            },
            {
                "name": "Iphone 15",
                "description": "512GB, Gray space",
                "price": 210000.0,
                "quantity": 8
            },
            {
                "name": "Xiaomi Redmi Note 11",
                "description": "1024GB, Синий",
                "price": 31000.0,
                "quantity": 14
            }
        ]
    },
    {
        "name": "Телевизоры",
        "description": "Современный телевизор, который позволяет наслаждаться просмотром, станет вашим другом и помощником",
        "products": [
            {
                "name": "55 QLED 4K",
                "description": "Фоновая подсветка",
                "price": 123000.0,
                "quantity": 7
            }
        ]
    }
]
products = []
for category in data:
    for product in category['products']:
        products.append(Product(**product))

product_item = Product('Test', 'Test', 1000, 10)
product_item_2 = Smartphone('Test2', 'Test2', 2000, 10, 1.5,  'Xiaomi', 10000, 'red')
product_item_3 = LawnGrass('Test3', 'Test3', 3000, 10, 'Canada', '1 year', 'light green')

product_data = {
    'name': 'New Product',
    'description': 'New Description',
    'price': 500,
    'quantity': 5
}

new_product = Product.new_product(product_data)

Тест 2
Тест не пройден ✗

Формулировка:

* Итоговый код для проверки.

import warnings

warnings.filterwarnings('ignore')

# Перенесите сюда свой код из прошлой домашки и продолжите работу с ним
from abc import ABC, abstractmethod
 
class InitPrintMixin:
    def __init_print__(self, *args):
        class_name = self.__class__.__name__
        params = ', '.join([f"'{arg}'" if isinstance(arg, str) else str(arg) for arg in args])
        print(f"{class_name}({params})")
 
class BaseProduct(ABC):
    def __init__(self, name, description, price, quantity):
        self.name = name
        self.description = description
        self._price = price
        self.quantity = quantity
 
    @property
    def price(self):
        return self._price
 
    @price.setter
    def price(self, value):
        if value <= 0:
            print("Цена не должна быть нулевая или отрицательная")
        else:
            self._price = value
 
    @abstractmethod
    def __str__(self):
        pass
 
    @classmethod
    @abstractmethod
    def new_product(cls, product_dict):
        pass
 
    def __add__(self, other):
        if type(self) is type(other):
            return self.price * self.quantity + other.price * other.quantity
        raise TypeError("Складывать можно только товары одного типа")
 
    def __len__(self):
        return self.quantity
 
class Product(BaseProduct, InitPrintMixin):
    def __init__(self, name, description, price, quantity):
        super().__init__(name, description, price, quantity)
        self.__init_print__(name, description, price, quantity)
 
    def __str__(self):
        return f"{self.name}, {self.price} руб. Остаток: {self.quantity} шт."
 
    def __repr__(self):
        return f"Product('{self.name}', '{self.description}', {self.price}, {self.quantity})"
 
    @classmethod
    def new_product(cls, product_dict):
        return cls(product_dict['name'], product_dict['description'], product_dict['price'], product_dict['quantity'])
 
class Smartphone(Product):
    def __init__(self, name, description, price, quantity, efficiency='Не указано', model='Не указано', memory=0, color='Не указан'):
        super(Product, self).__init__(name, description, price, quantity)  # Call BaseProduct directly to avoid double print
        self.efficiency = efficiency
        self.model = model
        self.memory = memory
        self.color = color
        self.__init_print__(name, description, price, quantity)
 
    def __repr__(self):
        return f"Smartphone('{self.name}', '{self.description}', {self.price}, {self.quantity})"
 
    @classmethod
    def new_product(cls, product_dict):
        return cls(
            product_dict['name'],
            product_dict['description'],
            product_dict['price'],
            product_dict['quantity'],
            product_dict.get('efficiency', 'Не указано'),
            product_dict.get('model', 'Не указано'),
            product_dict.get('memory', 0),
            product_dict.get('color', 'Не указан')
        )
 
    def __str__(self):
        return f"{self.name} ({self.model}), {self.price} руб. Остаток: {self.quantity} шт., цвет: {self.color}, память: {self.memory} ГБ, производительность: {self.efficiency}"
 
class LawnGrass(Product):
    def __init__(self, name, description, price, quantity, country='Не указано', germination_period='Не указано', color='Не указан'):
        super(Product, self).__init__(name, description, price, quantity)  # Call BaseProduct directly to avoid double print
        self.country = country
        self.germination_period = germination_period
        self.color = color
        self.__init_print__(name, description, price, quantity)
 
    def __repr__(self):
        return f"LawnGrass('{self.name}', '{self.description}', {self.price}, {self.quantity})"
 
    @classmethod
    def new_product(cls, product_dict):
        return cls(
            product_dict['name'],
            product_dict['description'],
            product_dict['price'],
            product_dict['quantity'],
            product_dict.get('country', 'Не указано'),
            product_dict.get('germination_period', 'Не указано'),
            product_dict.get('color', 'Не указан')
        )
 
    def __str__(self):
        return f"{self.name}, {self.price} руб. Остаток: {self.quantity} шт., страна: {self.country}, срок прорастания: {self.germination_period} дней, цвет: {self.color}"
 
class Category:
    category_count = 0
    product_count = 0
 
    def __init__(self, name, description, products=None):
        self.name = name
        self.description = description
        if products is None:
            products = []
        self._products = products
        Category.category_count += 1
        Category.product_count += len(products)
 
    def add_product(self, product):
        if isinstance(product, BaseProduct):
            self._products.append(product)
            Category.product_count += 1
        else:
            raise TypeError("Можно добавить только объекты класса Product или его наследников (Smartphone/LawnGrass)")
 
    @property
    def products(self):
        return "\n".join(str(product) for product in self._products)
 
    def __str__(self):
        total_quantity = sum(len(product) for product in self._products)
        return f"{self.name}, количество продуктов: {total_quantity} шт." 


data = [
    {
        "name": "Смартфоны",
        "description": "Смартфоны, как средство не только коммуникации, но и получение дополнительных функций для удобства жизни",
        "products": [
            {
                "name": "Samsung Galaxy C23 Ultra",
                "description": "256GB, Серый цвет, 200MP камера",
                "price": 180000.0,
                "quantity": 5
            },
            {
                "name": "Iphone 15",
                "description": "512GB, Gray space",
                "price": 210000.0,
                "quantity": 8
            },
            {
                "name": "Xiaomi Redmi Note 11",
                "description": "1024GB, Синий",
                "price": 31000.0,
                "quantity": 14
            }
        ]
    },
    {
        "name": "Телевизоры",
        "description": "Современный телевизор, который позволяет наслаждаться просмотром, станет вашим другом и помощником",
        "products": [
            {
                "name": "55 QLED 4K",
                "description": "Фоновая подсветка",
                "price": 123000.0,
                "quantity": 7
            }
        ]
    }
]
categories = []
for category in data:
    products = []
    for product in category['products']:
        products.append(Product.new_product(product))
    category['products'] = products
    categories.append(Category(**category))

product_item = Product('Test', 'Test', 1000, 10)
product_item_2 = Smartphone('Test2', 'Test2', 2000, 10, 1.5,  'Xiaomi', 10000, 'red')
product_item_3 = LawnGrass('Test3', 'Test3', 3000, 10, 'Canada', '1 year', 'light green')



try:
    categories[0].products = 1
except TypeError:
    print('Можно добавить только объекты класса Product или его наследников (Smartphone/LawnGrass)')

categories[0].products = product_item
print( product_item.name in categories[0].products)



Ожидаемый ответ:

Product('Samsung Galaxy C23 Ultra', '256GB, Серый цвет, 200MP камера', 180000.0, 5)
Product('Iphone 15', '512GB, Gray space', 210000.0, 8)
Product('Xiaomi Redmi Note 11', '1024GB, Синий', 31000.0, 14)
Product('55 QLED 4K', 'Фоновая подсветка', 123000.0, 7)
Product('Test', 'Test', 1000, 10)
Smartphone('Test2', 'Test2', 2000, 10)
LawnGrass('Test3', 'Test3', 3000, 10)
Можно добавить только объекты класса Product или его наследников (Smartphone/LawnGrass)
True

Ошибка:

Traceback (most recent call last):
  File "NJ0IK14PGM1TS1Y2SLBS.py", line 202, in <module>
    categories[0].products = 1
AttributeError: can't set attribute
Тест 3
Тест пройден успешно ✓

Формулировка:

* Итоговый код для проверки.

import warnings

warnings.filterwarnings('ignore')

# Перенесите сюда свой код из прошлой домашки и продолжите работу с ним
from abc import ABC, abstractmethod
 
class InitPrintMixin:
    def __init_print__(self, *args):
        class_name = self.__class__.__name__
        params = ', '.join([f"'{arg}'" if isinstance(arg, str) else str(arg) for arg in args])
        print(f"{class_name}({params})")
 
class BaseProduct(ABC):
    def __init__(self, name, description, price, quantity):
        self.name = name
        self.description = description
        self._price = price
        self.quantity = quantity
 
    @property
    def price(self):
        return self._price
 
    @price.setter
    def price(self, value):
        if value <= 0:
            print("Цена не должна быть нулевая или отрицательная")
        else:
            self._price = value
 
    @abstractmethod
    def __str__(self):
        pass
 
    @classmethod
    @abstractmethod
    def new_product(cls, product_dict):
        pass
 
    def __add__(self, other):
        if type(self) is type(other):
            return self.price * self.quantity + other.price * other.quantity
        raise TypeError("Складывать можно только товары одного типа")
 
    def __len__(self):
        return self.quantity
 
class Product(BaseProduct, InitPrintMixin):
    def __init__(self, name, description, price, quantity):
        super().__init__(name, description, price, quantity)
        self.__init_print__(name, description, price, quantity)
 
    def __str__(self):
        return f"{self.name}, {self.price} руб. Остаток: {self.quantity} шт."
 
    def __repr__(self):
        return f"Product('{self.name}', '{self.description}', {self.price}, {self.quantity})"
 
    @classmethod
    def new_product(cls, product_dict):
        return cls(product_dict['name'], product_dict['description'], product_dict['price'], product_dict['quantity'])
 
class Smartphone(Product):
    def __init__(self, name, description, price, quantity, efficiency='Не указано', model='Не указано', memory=0, color='Не указан'):
        super(Product, self).__init__(name, description, price, quantity)  # Call BaseProduct directly to avoid double print
        self.efficiency = efficiency
        self.model = model
        self.memory = memory
        self.color = color
        self.__init_print__(name, description, price, quantity)
 
    def __repr__(self):
        return f"Smartphone('{self.name}', '{self.description}', {self.price}, {self.quantity})"
 
    @classmethod
    def new_product(cls, product_dict):
        return cls(
            product_dict['name'],
            product_dict['description'],
            product_dict['price'],
            product_dict['quantity'],
            product_dict.get('efficiency', 'Не указано'),
            product_dict.get('model', 'Не указано'),
            product_dict.get('memory', 0),
            product_dict.get('color', 'Не указан')
        )
 
    def __str__(self):
        return f"{self.name} ({self.model}), {self.price} руб. Остаток: {self.quantity} шт., цвет: {self.color}, память: {self.memory} ГБ, производительность: {self.efficiency}"
 
class LawnGrass(Product):
    def __init__(self, name, description, price, quantity, country='Не указано', germination_period='Не указано', color='Не указан'):
        super(Product, self).__init__(name, description, price, quantity)  # Call BaseProduct directly to avoid double print
        self.country = country
        self.germination_period = germination_period
        self.color = color
        self.__init_print__(name, description, price, quantity)
 
    def __repr__(self):
        return f"LawnGrass('{self.name}', '{self.description}', {self.price}, {self.quantity})"
 
    @classmethod
    def new_product(cls, product_dict):
        return cls(
            product_dict['name'],
            product_dict['description'],
            product_dict['price'],
            product_dict['quantity'],
            product_dict.get('country', 'Не указано'),
            product_dict.get('germination_period', 'Не указано'),
            product_dict.get('color', 'Не указан')
        )
 
    def __str__(self):
        return f"{self.name}, {self.price} руб. Остаток: {self.quantity} шт., страна: {self.country}, срок прорастания: {self.germination_period} дней, цвет: {self.color}"
 
class Category:
    category_count = 0
    product_count = 0
 
    def __init__(self, name, description, products=None):
        self.name = name
        self.description = description
        if products is None:
            products = []
        self._products = products
        Category.category_count += 1
        Category.product_count += len(products)
 
    def add_product(self, product):
        if isinstance(product, BaseProduct):
            self._products.append(product)
            Category.product_count += 1
        else:
            raise TypeError("Можно добавить только объекты класса Product или его наследников (Smartphone/LawnGrass)")
 
    @property
    def products(self):
        return "\n".join(str(product) for product in self._products)
 
    def __str__(self):
        total_quantity = sum(len(product) for product in self._products)
        return f"{self.name}, количество продуктов: {total_quantity} шт." 


data = [
    {
        "name": "Смартфоны",
        "description": "Смартфоны, как средство не только коммуникации, но и получение дополнительных функций для удобства жизни",
        "products": [
            {
                "name": "Samsung Galaxy C23 Ultra",
                "description": "256GB, Серый цвет, 200MP камера",
                "price": 180000.0,
                "quantity": 5
            },
            {
                "name": "Iphone 15",
                "description": "512GB, Gray space",
                "price": 210000.0,
                "quantity": 8
            },
            {
                "name": "Xiaomi Redmi Note 11",
                "description": "1024GB, Синий",
                "price": 31000.0,
                "quantity": 14
            }
        ]
    },
    {
        "name": "Телевизоры",
        "description": "Современный телевизор, который позволяет наслаждаться просмотром, станет вашим другом и помощником",
        "products": [
            {
                "name": "55 QLED 4K",
                "description": "Фоновая подсветка",
                "price": 123000.0,
                "quantity": 7
            }
        ]
    }
]
categories = []
for category in data:
    products = []
    for product in category['products']:
        products.append(Product.new_product(product))
    category['products'] = products
    categories.append(Category(**category))

product_item = Product('Test', 'Test', 1000, 10)
product_item_2 = Smartphone('Test2', 'Test2', 2000, 10, 1.5,  'Xiaomi', 10000, 'red')
product_item_3 = LawnGrass('Test3', 'Test3', 3000, 10, 'Canada', '1 year', 'light green')

print(product_item_2.name) 
print(product_item_2.quantity)
print(product_item_2.description)
print(product_item_2.price)
print(product_item_2.efficiency)
print(product_item_2.model) 
print(product_item_2.model)
print(product_item_2.memory)
print(product_item_2.color)

Тест 4
Тест пройден успешно ✓

Формулировка:

* Итоговый код для проверки.

import warnings

warnings.filterwarnings('ignore')

# Перенесите сюда свой код из прошлой домашки и продолжите работу с ним
from abc import ABC, abstractmethod
 
class InitPrintMixin:
    def __init_print__(self, *args):
        class_name = self.__class__.__name__
        params = ', '.join([f"'{arg}'" if isinstance(arg, str) else str(arg) for arg in args])
        print(f"{class_name}({params})")
 
class BaseProduct(ABC):
    def __init__(self, name, description, price, quantity):
        self.name = name
        self.description = description
        self._price = price
        self.quantity = quantity
 
    @property
    def price(self):
        return self._price
 
    @price.setter
    def price(self, value):
        if value <= 0:
            print("Цена не должна быть нулевая или отрицательная")
        else:
            self._price = value
 
    @abstractmethod
    def __str__(self):
        pass
 
    @classmethod
    @abstractmethod
    def new_product(cls, product_dict):
        pass
 
    def __add__(self, other):
        if type(self) is type(other):
            return self.price * self.quantity + other.price * other.quantity
        raise TypeError("Складывать можно только товары одного типа")
 
    def __len__(self):
        return self.quantity
 
class Product(BaseProduct, InitPrintMixin):
    def __init__(self, name, description, price, quantity):
        super().__init__(name, description, price, quantity)
        self.__init_print__(name, description, price, quantity)
 
    def __str__(self):
        return f"{self.name}, {self.price} руб. Остаток: {self.quantity} шт."
 
    def __repr__(self):
        return f"Product('{self.name}', '{self.description}', {self.price}, {self.quantity})"
 
    @classmethod
    def new_product(cls, product_dict):
        return cls(product_dict['name'], product_dict['description'], product_dict['price'], product_dict['quantity'])
 
class Smartphone(Product):
    def __init__(self, name, description, price, quantity, efficiency='Не указано', model='Не указано', memory=0, color='Не указан'):
        super(Product, self).__init__(name, description, price, quantity)  # Call BaseProduct directly to avoid double print
        self.efficiency = efficiency
        self.model = model
        self.memory = memory
        self.color = color
        self.__init_print__(name, description, price, quantity)
 
    def __repr__(self):
        return f"Smartphone('{self.name}', '{self.description}', {self.price}, {self.quantity})"
 
    @classmethod
    def new_product(cls, product_dict):
        return cls(
            product_dict['name'],
            product_dict['description'],
            product_dict['price'],
            product_dict['quantity'],
            product_dict.get('efficiency', 'Не указано'),
            product_dict.get('model', 'Не указано'),
            product_dict.get('memory', 0),
            product_dict.get('color', 'Не указан')
        )
 
    def __str__(self):
        return f"{self.name} ({self.model}), {self.price} руб. Остаток: {self.quantity} шт., цвет: {self.color}, память: {self.memory} ГБ, производительность: {self.efficiency}"
 
class LawnGrass(Product):
    def __init__(self, name, description, price, quantity, country='Не указано', germination_period='Не указано', color='Не указан'):
        super(Product, self).__init__(name, description, price, quantity)  # Call BaseProduct directly to avoid double print
        self.country = country
        self.germination_period = germination_period
        self.color = color
        self.__init_print__(name, description, price, quantity)
 
    def __repr__(self):
        return f"LawnGrass('{self.name}', '{self.description}', {self.price}, {self.quantity})"
 
    @classmethod
    def new_product(cls, product_dict):
        return cls(
            product_dict['name'],
            product_dict['description'],
            product_dict['price'],
            product_dict['quantity'],
            product_dict.get('country', 'Не указано'),
            product_dict.get('germination_period', 'Не указано'),
            product_dict.get('color', 'Не указан')
        )
 
    def __str__(self):
        return f"{self.name}, {self.price} руб. Остаток: {self.quantity} шт., страна: {self.country}, срок прорастания: {self.germination_period} дней, цвет: {self.color}"
 
class Category:
    category_count = 0
    product_count = 0
 
    def __init__(self, name, description, products=None):
        self.name = name
        self.description = description
        if products is None:
            products = []
        self._products = products
        Category.category_count += 1
        Category.product_count += len(products)
 
    def add_product(self, product):
        if isinstance(product, BaseProduct):
            self._products.append(product)
            Category.product_count += 1
        else:
            raise TypeError("Можно добавить только объекты класса Product или его наследников (Smartphone/LawnGrass)")
 
    @property
    def products(self):
        return "\n".join(str(product) for product in self._products)
 
    def __str__(self):
        total_quantity = sum(len(product) for product in self._products)
        return f"{self.name}, количество продуктов: {total_quantity} шт." 


data = [
    {
        "name": "Смартфоны",
        "description": "Смартфоны, как средство не только коммуникации, но и получение дополнительных функций для удобства жизни",
        "products": [
            {
                "name": "Samsung Galaxy C23 Ultra",
                "description": "256GB, Серый цвет, 200MP камера",
                "price": 180000.0,
                "quantity": 5
            },
            {
                "name": "Iphone 15",
                "description": "512GB, Gray space",
                "price": 210000.0,
                "quantity": 8
            },
            {
                "name": "Xiaomi Redmi Note 11",
                "description": "1024GB, Синий",
                "price": 31000.0,
                "quantity": 14
            }
        ]
    },
    {
        "name": "Телевизоры",
        "description": "Современный телевизор, который позволяет наслаждаться просмотром, станет вашим другом и помощником",
        "products": [
            {
                "name": "55 QLED 4K",
                "description": "Фоновая подсветка",
                "price": 123000.0,
                "quantity": 7
            }
        ]
    }
]
categories = []
for category in data:
    products = []
    for product in category['products']:
        products.append(Product.new_product(product))
    category['products'] = products
    categories.append(Category(**category))

product_item = Product('Test', 'Test', 1000, 10)
product_item_2 = Smartphone('Test2', 'Test2', 2000, 10, 1.5,  'Xiaomi', 10000, 'red')
product_item_3 = LawnGrass('Test3', 'Test3', 3000, 10, 'Canada', '1 year', 'light green')


print(product_item_3.country)
print(product_item_3.germination_period)
print(product_item_3.color)
print(product_item_3.name) 
print(product_item_3.description) 
print(product_item_3.price) 
print(product_item_3.quantity)